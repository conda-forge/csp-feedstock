From 498d4148ebeabdd026f71e1f9ebd22ae8dff3b12 Mon Sep 17 00:00:00 2001
From: Tim Paine <3105306+timkpaine@users.noreply.github.com>
Date: Thu, 25 Sep 2025 22:11:22 -0400
Subject: [PATCH] enable numpy 2

---
 cpp/csp/python/NumpyConversions.cpp           | 99 +++++++++++++------
 cpp/csp/python/NumpyConversions.h             |  4 +-
 cpp/csp/python/NumpyInputAdapter.h            | 24 +++--
 cpp/csp/python/PyNumpyAdapter.cpp             | 15 +--
 .../python/adapters/parquetadapterimpl.cpp    |  8 +-
 cpp/csp/python/cspbaselibimpl.cpp             |  6 +-
 cpp/csp/python/cspimpl.cpp                    |  2 +
 cpp/csp/python/cspnpstatsimpl.cpp             |  4 +-
 cpp/csp/python/npstatsimpl.cpp                |  2 -
 pyproject.toml                                |  4 +-
 10 files changed, 109 insertions(+), 59 deletions(-)

diff --git a/cpp/csp/python/NumpyConversions.cpp b/cpp/csp/python/NumpyConversions.cpp
index 9825440..1f84389 100644
--- a/cpp/csp/python/NumpyConversions.cpp
+++ b/cpp/csp/python/NumpyConversions.cpp
@@ -1,5 +1,6 @@
 //this is included first so that we do include without NO_IMPORT_ARRAY defined, which is done in NumpyConversions.h
 #include <numpy/ndarrayobject.h>
+#include <numpy/npy_2_compat.h>
 
 
 #include <csp/core/Time.h>
@@ -8,21 +9,21 @@
 #include <locale>
 #include <codecvt>
 
-namespace csp::python
+static void * init_nparray()
 {
+    csp::python::AcquireGIL gil;
+    import_array();
+    return nullptr;
+}
+static void * s_init_array = init_nparray();
 
-static bool numpy_initialized = false;
+namespace csp::python
+{
 
 PyObject * valuesAtIndexToNumpy( ValueType valueType, const csp::TimeSeriesProvider * ts, int32_t startIndex, int32_t endIndex,
                                  autogen::TimeIndexPolicy startPolicy, autogen::TimeIndexPolicy endPolicy,
                                  DateTime startDt, DateTime endDt )
 {
-    if( !numpy_initialized )
-    {
-        import_array()
-        numpy_initialized = true;
-    }
-
     return switchCspType( ts -> type(),
                           [ valueType, ts, startIndex, endIndex, startPolicy, endPolicy, startDt, endDt ]( auto tag )
                           {
@@ -35,32 +36,69 @@ int64_t scalingFromNumpyDtUnit( NPY_DATETIMEUNIT base )
 {
     switch( base )
     {
-        case NPY_FR_ns:
-            return 1;
-        case NPY_FR_us:
-            return csp::TimeDelta::fromMicroseconds(1).asNanoseconds();
-        case NPY_FR_ms:
-            return csp::TimeDelta::fromMilliseconds(1).asNanoseconds();
-        case NPY_FR_s:
-            return csp::TimeDelta::fromSeconds(1).asNanoseconds();
-        case NPY_FR_m:
-            return csp::TimeDelta::fromMinutes(1).asNanoseconds();
-        case NPY_FR_h:
-            return csp::TimeDelta::fromHours(1).asNanoseconds();
-        case NPY_FR_D:
-            return csp::TimeDelta::fromDays(1).asNanoseconds();
+        // https://github.com/numpy/numpy/blob/v2.0.0/numpy/__init__.pxd#L794
+        case NPY_FR_Y:
+            return csp::TimeDelta::fromDays(365).asNanoseconds();
+        case NPY_FR_M:
+            return csp::TimeDelta::fromDays(30).asNanoseconds();
         case NPY_FR_W:
             return csp::TimeDelta::fromDays(7).asNanoseconds();
+#ifdef NPY_FR_B
+        case NPY_FR_B:
+            return csp::TimeDelta::fromDays(5).asNanoseconds();
+#endif
+        case NPY_FR_D:
+            return csp::TimeDelta::fromDays(1).asNanoseconds();
+        case NPY_FR_h:
+            return csp::TimeDelta::fromHours(1).asNanoseconds();
+        case NPY_FR_m:
+            return csp::TimeDelta::fromMinutes(1).asNanoseconds();
+        case NPY_FR_s:
+            return csp::TimeDelta::fromSeconds(1).asNanoseconds();
+        case NPY_FR_ms:
+            return csp::TimeDelta::fromMilliseconds(1).asNanoseconds();
+        case NPY_FR_us:
+            return csp::TimeDelta::fromMicroseconds(1).asNanoseconds();
+        case NPY_FR_ns:
+            return 1;
+        // unsupported or invalid units
+        // enumerated here for clarity in error messages
+        case NPY_FR_ps:
+            CSP_THROW(csp::NotImplemented, "datetime resolution not supported or invalid - saw NPY_DATETIMEUNIT value NPY_FR_ps" );
+            return 0;
+        case NPY_FR_fs:
+            CSP_THROW(csp::NotImplemented, "datetime resolution not supported or invalid - saw NPY_DATETIMEUNIT value NPY_FR_fs" );
+            return 0;
+        case NPY_FR_GENERIC:
+            CSP_THROW(csp::NotImplemented, "datetime resolution not supported or invalid - saw NPY_DATETIMEUNIT value NPY_FR_generic" );
+            return 0;
+        case NPY_FR_ERROR:
+            CSP_THROW(csp::NotImplemented, "datetime resolution not supported or invalid - saw NPY_DATETIMEUNIT value NPY_FR_error" );
+            return 0;
         default:
-            CSP_THROW(csp::NotImplemented, "datetime resolution not supported or invalid - saw NPY_DATETIMEUNIT value " << base );
-            return 0;  // never reached, but keeps compiler happy
+            if(static_cast<int>(base) == 3) {
+                // NPY_FR_B was removed in numpy 1.20
+                return csp::TimeDelta::fromDays(5).asNanoseconds();
+            }
+            CSP_THROW(csp::NotImplemented, "datetime resolution not supported or invalid - saw NPY_DATETIMEUNIT value " << static_cast<int32_t>(base) );
+            return 0;
     }
 }
 
 NPY_DATETIMEUNIT datetimeUnitFromDescr( PyArray_Descr* descr )
 {
-    PyArray_DatetimeDTypeMetaData* dtypeMeta = (PyArray_DatetimeDTypeMetaData*)(descr -> c_metadata);
-    PyArray_DatetimeMetaData* dtMeta = &(dtypeMeta -> meta);
+    PyArray_DatetimeDTypeMetaData* dtypeMeta;
+    if (PyArray_RUNTIME_VERSION >= NPY_2_0_API_VERSION)
+    {
+        // NumPy 2.x way
+        dtypeMeta = ( PyArray_DatetimeDTypeMetaData * ) ( ( (_PyArray_LegacyDescr *) descr ) -> c_metadata );
+    }
+    else
+    {
+        // NumPy 1.x way
+        dtypeMeta = ( PyArray_DatetimeDTypeMetaData * ) ( ( (PyArray_DescrProto *) descr ) -> c_metadata );
+    }
+    PyArray_DatetimeMetaData* dtMeta = &( dtypeMeta -> meta );
     return dtMeta -> base;
 }
 
@@ -68,7 +106,7 @@ static std::wstring_convert<std::codecvt_utf8<char32_t>, char32_t> wstr_converte
 
 void stringFromNumpyStr( void* data, std::string& out, char numpy_type, int elem_size_bytes )
 {
-    // strings from numpy arrays are fixed width and zero filled.  
+    // strings from numpy arrays are fixed width and zero filled.
     // if the last char is 0, can treat as null terminated, else use full width
 
     if( numpy_type == NPY_UNICODELTR)
@@ -87,7 +125,7 @@ void stringFromNumpyStr( void* data, std::string& out, char numpy_type, int elem
             out = wstr_converter.to_bytes( wstr );
         }
     }
-    else if( numpy_type == NPY_STRINGLTR || numpy_type == NPY_STRINGLTR2 )
+    else if( numpy_type == NPY_STRINGLTR )
     {
         const char * const raw_value = (const char *) data;
 
@@ -120,13 +158,13 @@ void validateNumpyTypeVsCspType( const CspTypePtr & type, char numpy_type_char )
         case NPY_INTLTR:
         case NPY_UINTLTR:
         case NPY_LONGLTR:
+        case NPY_LONGLONGLTR:
             if( cspType != csp::CspType::Type::INT64 )
                 CSP_THROW( ValueError, "numpy type " << numpy_type_char << " requires int output type" );
             break;
         case NPY_ULONGLTR:
-        case NPY_LONGLONGLTR:
         case NPY_ULONGLONGLTR:
-            CSP_THROW( ValueError, "numpy type " << numpy_type_char << " (int type that can't cleanly convert to long) not supported" );
+            CSP_THROW( ValueError, "numpy type " << numpy_type_char << " (int type that can't cleanly convert to int64) not supported" );
         case NPY_HALFLTR:
             CSP_THROW( ValueError, "numpy type " << numpy_type_char << " (numpy half float) not supported" );
         case NPY_FLOATLTR:
@@ -144,7 +182,6 @@ void validateNumpyTypeVsCspType( const CspTypePtr & type, char numpy_type_char )
             // everything works as object
             break;
         case NPY_STRINGLTR:
-        case NPY_STRINGLTR2:
         case NPY_UNICODELTR:
         case NPY_CHARLTR:
             if( cspType != csp::CspType::Type::STRING )
diff --git a/cpp/csp/python/NumpyConversions.h b/cpp/csp/python/NumpyConversions.h
index 04ce787..e4d22b5 100644
--- a/cpp/csp/python/NumpyConversions.h
+++ b/cpp/csp/python/NumpyConversions.h
@@ -204,7 +204,7 @@ inline PyObject * createNumpyArray( ValueType valueType, const csp::TimeSeriesPr
     T lastValue;
     if( ts -> valid() )
         lastValue = ts -> lastValueTyped<T>();
-    
+
     DateTime lastTime = ( ts -> valid() ? ts -> lastTime() : DateTime() );
     switch( valueType )
     {
@@ -219,7 +219,7 @@ inline PyObject * createNumpyArray( ValueType valueType, const csp::TimeSeriesPr
         case ValueType::TIMESTAMP_VALUE_TUPLE:
         {
             PyObject * tuple = PyTuple_New( 2 );
-            PyTuple_SET_ITEM( tuple, 0, adjustStartAndEndTime( as_nparray( ts, ts -> timeline(), lastTime, startIndex, 
+            PyTuple_SET_ITEM( tuple, 0, adjustStartAndEndTime( as_nparray( ts, ts -> timeline(), lastTime, startIndex,
                                         endIndex, extrapolateEnd ), startPolicy, endPolicy, startDt, endDt ) );
             PyTuple_SET_ITEM( tuple, 1, as_nparray( ts, ts -> dataline<T>(), lastValue, startIndex, endIndex, extrapolateEnd ) );
             return tuple;
diff --git a/cpp/csp/python/NumpyInputAdapter.h b/cpp/csp/python/NumpyInputAdapter.h
index 0d4bd7c..b7e87ce 100644
--- a/cpp/csp/python/NumpyInputAdapter.h
+++ b/cpp/csp/python/NumpyInputAdapter.h
@@ -29,18 +29,18 @@ public:
         m_descr = nullptr;
     }
 
-    NumpyCurveAccessor( PyArrayObject * arr ) 
+    NumpyCurveAccessor( PyArrayObject * arr )
     {
         m_nd = PyArray_NDIM( arr );
         if( m_nd < 2 )
             CSP_THROW( csp::TypeError, "NumpyCurveAccessor is inefficient for a 1-D Numpy array: use PyArray_GETPTR1 to access indexed values" );
-        
+
         // Preprocess strides and dimensions
         npy_intp* strides = PyArray_STRIDES( arr );
         npy_intp* dims = PyArray_DIMS( arr );
         m_outerStride = strides[0];
         m_outerDim = dims[0];
-        m_innerStrides = strides + 1; 
+        m_innerStrides = strides + 1;
         m_innerDims = dims + 1;
 
         m_arr = arr;
@@ -58,7 +58,7 @@ public:
     {
         if( index >= m_outerDim )
             CSP_THROW( csp::TypeError, "Requested data index out of range in NumpyCurveAccessor" );
-        
+
         // Create a view to the (n-1) dimensional array with (n-1) potentially unnatural strides
         /*
         A note on reference counting for the subarray: NewFromDescr will *steal* a reference to the type descr,
@@ -87,7 +87,7 @@ public:
 private:
     char* m_data;
     int m_nd;
-    
+
     npy_intp m_outerStride;
     npy_intp m_outerDim;
     npy_intp* m_innerStrides;
@@ -103,7 +103,7 @@ class NumpyInputAdapter : public PullInputAdapter<T>
     using PyArrayObjectPtr = PyPtr<PyArrayObject>;
 
 public:
-    NumpyInputAdapter( Engine * engine, CspTypePtr & type, PyArrayObject * datetimes, 
+    NumpyInputAdapter( Engine * engine, CspTypePtr & type, PyArrayObject * datetimes,
                        PyArrayObject * values ) : PullInputAdapter<T>( engine, type, PushMode::LAST_VALUE ),
                                                   m_datetimes( PyArrayObjectPtr::incref( datetimes ) ),
                                                   m_values( PyArrayObjectPtr::incref( values ) ),
@@ -113,7 +113,7 @@ public:
         PyArray_Descr* vals_descr = PyArray_DESCR(m_values.ptr());
 
         m_size = static_cast<int>(PyArray_SIZE( datetimes ));
-        m_elem_size = vals_descr -> elsize;
+        m_elem_size = PyDataType_ELSIZE(vals_descr);
         m_val_type = vals_descr -> type;
 
         char out_type = m_val_type;
@@ -123,7 +123,7 @@ public:
             m_valueAccessor = std::make_unique<NumpyCurveAccessor>( m_values.ptr() );
         }
         validateNumpyTypeVsCspType( type, out_type );
-        
+
 
         auto dt_type = dts_descr -> type;
         if( dt_type != NPY_DATETIMELTR && dt_type != NPY_OBJECTLTR )
@@ -166,7 +166,7 @@ public:
 
             ++m_index;
         }
- 
+
         PullInputAdapter<T>::start( start, end );
     }
 
@@ -290,6 +290,12 @@ void NumpyInputAdapter<int64_t>::setValue( int64_t & value, void * data )
             value = static_cast<int64_t>(*val);
             break;
         }
+        case NPY_LONGLONGLTR:
+        {
+            const long long * const val = (const long long*)data;
+            value = static_cast<int64_t>(*val);
+            break;
+        }
         default:
             CSP_THROW( ValueError, "NumpyInputAdapter<int64_t>::setValue sees invalid numpy type " << m_val_type );
     }
diff --git a/cpp/csp/python/PyNumpyAdapter.cpp b/cpp/csp/python/PyNumpyAdapter.cpp
index cf08da8..61d3d99 100644
--- a/cpp/csp/python/PyNumpyAdapter.cpp
+++ b/cpp/csp/python/PyNumpyAdapter.cpp
@@ -10,19 +10,20 @@
 #include <csp/python/PyEngine.h>
 #include <csp/python/PyInputAdapterWrapper.h>
 
+static void * init_nparray()
+{
+    csp::python::AcquireGIL gil;
+    import_array();
+    return nullptr;
+}
+static void * s_init_array;
 
 namespace csp::python
 {
 
-static bool numpy_initialized = false;
-
 static InputAdapter * numpy_adapter_creator( csp::AdapterManager * manager, PyEngine * pyengine, PyObject * pyType, PushMode pushMode, PyObject * args )
 {
-    if( !numpy_initialized )
-    {
-        import_array()
-        numpy_initialized = true;
-    }  
+    s_init_array = init_nparray();
 
     PyObject * type;
     PyArrayObject * pyDatetimes = nullptr;
diff --git a/cpp/csp/python/adapters/parquetadapterimpl.cpp b/cpp/csp/python/adapters/parquetadapterimpl.cpp
index 6d3f958..171cb3e 100644
--- a/cpp/csp/python/adapters/parquetadapterimpl.cpp
+++ b/cpp/csp/python/adapters/parquetadapterimpl.cpp
@@ -25,6 +25,7 @@
 #include <codecvt>
 
 using namespace csp::adapters::parquet;
+
 //using namespace csp::cppnodes;
 //namespace csp::adapters::parquet
 namespace csp::cppnodes
@@ -284,7 +285,7 @@ public:
                                                          PyObject_Repr( ( PyObject * ) PyArray_DESCR( arrayObject ) ) ) );
         }
 
-        auto elementSize = PyArray_DESCR( arrayObject ) -> elsize;
+        auto elementSize = PyDataType_ELSIZE( PyArray_DESCR( arrayObject ) );
         auto ndim        = PyArray_NDIM( arrayObject );
 
         CSP_TRUE_OR_THROW_RUNTIME( ndim == 1, "While writing to parquet expected numpy array with 1 dimension" << " got " << ndim );
@@ -432,7 +433,7 @@ public:
     {
         auto arrayObject = reinterpret_cast<PyArrayObject *>(csp::python::toPythonBorrowed( list ));
         std::wstring_convert<std::codecvt_utf8<char32_t>,char32_t> converter;
-        auto elementSize = PyArray_DESCR( arrayObject ) -> elsize;
+        auto elementSize = PyDataType_ELSIZE( PyArray_DESCR( arrayObject ) );
         auto wideValue = converter.from_bytes( value );
         auto nElementsToCopy = std::min( int(elementSize / sizeof(char32_t)), int( wideValue.size() + 1 ) );
         std::copy_n( wideValue.c_str(), nElementsToCopy, reinterpret_cast<char32_t*>(PyArray_GETPTR1( arrayObject, index )) );
@@ -666,8 +667,9 @@ static PyModuleDef _parquetadapterimpl_module = {
 PyMODINIT_FUNC PyInit__parquetadapterimpl( void )
 {
     PyObject *m;
-
+    
     m = PyModule_Create( &_parquetadapterimpl_module );
+
     if( m == NULL )
     {
         return NULL;
diff --git a/cpp/csp/python/cspbaselibimpl.cpp b/cpp/csp/python/cspbaselibimpl.cpp
index 1ada5ce..9289e80 100644
--- a/cpp/csp/python/cspbaselibimpl.cpp
+++ b/cpp/csp/python/cspbaselibimpl.cpp
@@ -1,9 +1,10 @@
+#include <exprtk.hpp>
+#include <numpy/ndarrayobject.h>
+
 #include <csp/python/Common.h>
 #include <csp/python/PyCppNode.h>
 #include <csp/engine/CppNode.h>
 #include <csp/python/Conversions.h>
-#include <exprtk.hpp>
-#include <numpy/ndarrayobject.h>
 
 static void * init_nparray()
 {
@@ -364,6 +365,7 @@ PyMODINIT_FUNC PyInit__cspbaselibimpl(void)
     PyObject* m;
 
     m = PyModule_Create( &_cspbaselibimpl_module);
+
     if( m == NULL )
         return NULL;
 
diff --git a/cpp/csp/python/cspimpl.cpp b/cpp/csp/python/cspimpl.cpp
index 8527aeb..7e3ef45 100644
--- a/cpp/csp/python/cspimpl.cpp
+++ b/cpp/csp/python/cspimpl.cpp
@@ -5,6 +5,7 @@
 #include <csp/python/PyNode.h>
 #include <frameobject.h>
 #include <traceback.h>
+
 namespace csp::python
 {
 
@@ -140,6 +141,7 @@ PyMODINIT_FUNC PyInit__cspimpl(void)
     PyObject* m;
 
     m = PyModule_Create( &_cspimpl_module);
+
     if( m == NULL )
         return NULL;
 
diff --git a/cpp/csp/python/cspnpstatsimpl.cpp b/cpp/csp/python/cspnpstatsimpl.cpp
index 87d13e9..83e26fe 100644
--- a/cpp/csp/python/cspnpstatsimpl.cpp
+++ b/cpp/csp/python/cspnpstatsimpl.cpp
@@ -1,3 +1,4 @@
+#include <numpy/ndarrayobject.h>
 #include <csp/engine/CppNode.h>
 #include <csp/python/PyCppNode.h>
 
@@ -66,6 +67,7 @@ PyMODINIT_FUNC PyInit__cspnpstatsimpl(void)
     PyObject* m;
 
     m = PyModule_Create( &_cspnpstatsimpl_module);
+
     if( m == NULL )
         return NULL;
 
@@ -73,4 +75,4 @@ PyMODINIT_FUNC PyInit__cspnpstatsimpl(void)
         return NULL;
 
     return m;
-}
\ No newline at end of file
+}
diff --git a/cpp/csp/python/npstatsimpl.cpp b/cpp/csp/python/npstatsimpl.cpp
index f691e81..53de3b6 100644
--- a/cpp/csp/python/npstatsimpl.cpp
+++ b/cpp/csp/python/npstatsimpl.cpp
@@ -26,8 +26,6 @@ template<> struct NPY_TYPE<double>   { static const int value = NPY_DOUBLE; };
 
 using namespace csp::cppnodes;
 
-// NumPy specific statistic functions
-
 static void * init_nparray()
 {
     csp::python::AcquireGIL gil;
diff --git a/pyproject.toml b/pyproject.toml
index 6893417..0834dd5 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -2,7 +2,7 @@
 requires = [
     "cmake<3.27",
     "deprecated",  # Because used in csp.impl.struct, which is used in autogen
-    "oldest-supported-numpy",
+    "numpy>=2",
     "pyarrow>=15",
     "ruamel.yaml",
     "scikit-build",
@@ -21,7 +21,7 @@ requires-python = ">=3.9"
 
 dependencies = [
     "deprecated",
-    "numpy<2",
+    "numpy",
     "packaging",
     "pandas<2.3; python_version<'3.10'",
     "pandas; python_version>='3.10'",
-- 
2.43.0

